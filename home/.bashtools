#!/bin/bash

# A collection of bash helpers that have no external dependencies other than standard *nix tools.

# report where a tool's definition is: executable, alias, or function
function btwhich()
{
    local found=false
    \which "$*" 2>/dev/null && found=true
    alias "$*" 2>/dev/null && found=true
    declare -f "$*" 2>/dev/null && found=true
    $found
}
export -f btwhich

# boolean check for existence of a tool (based on btwhich above)
function ihave()
{
    btwhich "$*" >/dev/null 2>&1
}
export -f ihave

# boolean check if in/out/err are ttys
function istty()
{
    local fd
    case "$1" in
        in|stdin)   fd=0;;
        out|stdout) fd=1;;
        err|stderr) fd=2;;
        *)
            echo 'usage: istty {[std]in|[std]out|[std]err}' >&2
            return 1
    esac
    test -t $fd
}
export -f istty

function hasupper()
{
    local ure='[A-Z]'
    [[ "$*" =~ $ure ]]
}
export -f hasupper

# convert values into all uppercase or all lowercase
function caseit()
{
    local d=$1; shift
    local u='[:upper:]'
    local l='[:lower:]'
    local tr
    [ "$d" = 'up' ] && tr="tr '$l' '$u'" || tr="tr '$u' '$l'"
    [ $# -gt 0 ] && echo "$*" | $tr || $tr
}
alias downcase='caseit down'
alias upcase='caseit up'

# quote/escape arguments in a bash-safe way to pass to a subshell
function shellwords()
{
    printf ' %q' "$@"
}
export -f shellwords

# simple random string generator (temporary password usage ok, but it is not strong)
function randstring()
{
    local len=${1:-10}
    head -c "$len" /dev/urandom | base64 | head -c "$len"
}
export -f randstring

# replace all non-ascii with dot except tab, linefeed, and carriage return
function sanitize()
{
    # use locale to trick tr into processing truly binary content and not expecting text
    LC_ALL=C tr -c '\11\12\15\40-\176' '.'
}
export -f sanitize

# remove all color codes from stdin (or file, if provided) and write to stdout
function stripansi()
{
    sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' "$@"
}
export -f stripansi

# combine arguments:
#   join , one two three => one,two,three
# also works nicely with quoted values:
#   join $'\n' "one two three" "four five" "six seven" => one tow three\nfour fix\nsix seven
# BUG: will not work with $'\0' because Bash uses nulls as string terminators
#      decent workaround is to use the 'end-of-text' marker: $'\3' (or tabs $'\t')
#      ...which works nicely with awk to handle quotes: | awk -F$'\3' '{ print $3 }'
# see-also: ~/bin/pipejoin
function join()
{
    local IFS="$1"; shift; echo -n "$*";
}
export -f join

function push()
{
    eval "${1}+=(\"$2\")"
}
export -f push

function pop()
{
    echo "${1[-1]}"
    eval "${2}=\"${1[-1]}\""
    eval "${1}=(\"\${array[@]/\$${2}}\")"
}
export -f pop

# extracts arguments into two arrays (OPTIONAL_ARGS and POSITIONAL_ARGS) based on dash prefix
# FIXME: this will break on options that have values...
function split_args()
{
    local arg
    OPTIONAL_ARGS=()
    POSITIONAL_ARGS=()
    for arg in "$@"; do
        if [[ "$arg" = '-'* ]]; then
            OPTIONAL_ARGS=("${OPTIONAL_ARGS[@]}" "$arg")
        else
            POSITIONAL_ARGS=("${POSITIONAL_ARGS[@]}" "$arg")
        fi
    done
}
export -f split_args

HELPERS=()
function register_helper()
{
    export ${1}="${2}"
    HELPERS+=("$1")
}

function helpers()
{
    local h v
    for h in "${HELPERS[@]}"; do
        eval v=\$"$h"
        echo "${h}=${v}"
    done
}

# apply a prefix to every line from standard input (stdin) and write to standard out (stdout)
function prefix()
{
    if [ $# -lt 1 ]; then
        echo 'usage: prefix <prefix>...' >&2
        return 1
    fi
    local line
    while read -r line; do echo "${*}${line}"; done
}
export -f prefix

# prefix a timestamp to each line of output (all arguments are passed to "date")
register_helper ISO8601_FMT '+%Y-%m-%dT%H:%M:%S%z'
register_helper EPOCH_FMT '+%s.%N'
function predate()
{
    local line
    while read -r line; do echo "$(date "$@") ${line}"; done
}
export -f predate

# provide incrementing prefix values (useful for generating file names)
export INC_DN="${HOME}/.bashtools_inc"
mkdir -p "$INC_DN"
find "$INC_DN" -mtime +1 -type f -delete
function inc()
{
    local count
    if [ $# -ne 1 ]; then
        echo 'usage: inc <prefix>' >&2
        return 1
    fi
    local fn="${INC_DN}/${1}"
    count=$(cat "$fn" 2>/dev/null || echo 1)
    echo "$(( count + 1 ))" >"$fn"
    echo "${1}-${count}"
}
export -f inc

# simple calculator with optional precision
# TODO: consider way to safely strip commas from all numbers
function calc()
{
    local s=10
    if [ "$1" = '-p' ]; then shift; s="$1"; shift; fi
    # use printf to round since scaling affects bc's operations of precision
    V="$(printf "%.${s}f\n" "$(echo "scale=20;$*" | bc)")"
    echo "$V" # note, $V is "exposed" for use by caller
}
export -f calc

# helpers to use in calc calls: calc "1.7 $GiB" => 1825361100.7999999523
register_helper MiB '*1048576'
register_helper GiB '*1073741824'
register_helper minutes '*60'
register_helper hours '*3600'
register_helper days '*86400'

# computes a sum of all numbers produced by generator (i.e. reads stdin)
# e.g. (echo 1; echo 2) | pipesum 0 1 => 3
# see-also: https://www.gnu.org/software/datamash/alternatives/
# Datamash is a great command line statistical analysis tool!
function pipesum()
{
    if [ $# -ne 2 ]; then
        echo 'usage: pipesum <progress_count_interval> <column_number>' >&2
        return 1
    fi
    if [ $1 -gt 0 ]; then
        awk '{ cnt++; sum += $'$2'; if (cnt % '$1' == 0) { print cnt":", sum }} END { print "final:", sum }'
    else
        awk '{ sum += $'$2' } END { print sum }'
    fi
}
export -f pipesum
