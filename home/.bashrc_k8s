#  -*- mode: shell-script -*-

#
# Make kubectl friendlier
#

# NOTE: to pin kubectl at a particular version, follow these steps:
#       http://zoltanaltfatter.com/2017/09/07/Install-a-specific-version-of-formula-with-homebrew/
#       but remember to run `brew pin kubernetes-cli` before updating

# list all interesting context names
function kctxs()
{
    kubectl config get-contexts -oname
}

# exec args for each context found (ignoring minikube)
function keachctx()
{
    local ctx
    if [[ $# -lt 1 ]]; then
        cat <<EOF >&2
usage: keachctx <command> [<arg> ....]
[ NOTE: command is eval'd with a \$cxt variable available ]
EOF
        return 1
    fi
    for ctx in $(kctxs); do
        eval "$@"
    done
}

# list all internal node IPs
function knodeips()
{
    kubectl "$@" get nodes \
            -o jsonpath='{.items[*].status.addresses[?(@.type=="InternalIP")].address}'
}

# run a command on each node async
function keachnode()
{
    local esc cmd ip line
    if [[ "$1" = '--no-escape' ]]; then
        shift; esc=false
    else
        esc=true
    fi
    if [[ $# -lt 1 ]]; then
        echo "usage: keachnode [--no-escape] <cmd> [<args>...]" >&2
        return 1
    fi
    if $esc; then
        cmd=$(shellwords "$@")
    else
        cmd="$*"
    fi
    for ip in $(knodeips "$@"); do
        pgrep -qf "ssh: .*@${ip}" || ssh "$ip" : # start background ssh control session
        ( ( ssh "$ip" $cmd 2>&1 | while read -r line; do printf '%-15s %s\n' "${ip}:" "${line}"; done ) & )
    done
    sleep 1
    wait
}

# get uptimes for all nodes sorted by descending load (highest load at top)
function kuptime()
{
    keachnode "$@" uptime | sort -rnk 11
}

# get memory usage for all nodes sorted by ascending free memory (smallest memory available at top)
function kmem()
{
    printf '%15s %s\n' '[megabytes]' '             total       used       free     shared    buffers     cached'
    keachnode "$@" sh -c 'free -m | grep ^Mem' | sort -nk 5
}

# get file system usage for all nodes sorted by percent used (smallest space available at top)
function kdf()
{
    printf '%-15s %s\n' 'Host' 'Filesystem              Size  Used Avail Use% Mounted on'
    keachnode "$@" sh -c 'df -h / /var/lib/docker | sed 1d' | sort -rnk 6
}

# get the current namespace
function kns()
{
    kubectl config get-contexts | awk '$1 == "*" {print $5}'
}

# switch to a new default namespace (and optionally a new context) with partial matching
function ku()
{
    local ctx ns

    if [[ $# -lt 1 ]]; then
        kubectl config get-contexts | \
            awk '{if($1 ~ /^\*/){print "\033[30m\033[43m" $0 "\033[0m"}else{print}}'
        return
    fi

    if [[ $# -eq 2 ]]; then
        ctx=$(kctxs | sort -r | grep -m1 "$1")
        if [[ -z "$ctx" ]]; then
            echo 'no match found' >&2
            return 2
        fi
        shift
        kubectl config use-context "$ctx"
    elif [[ $# -eq 1 ]]; then
        ctx=$(kubectl config current-context)
    else
        cat <<EOF >&2
usage: ku <namespace>
       ku <context> <namespace>
EOF
        return 1
    fi

    ns=$(kubectl get ns -oname | cut -d/ -f2 | sort | grep -m1 "$1")
    if [[ -z "$ns" ]]; then
        echo 'no match found' >&2
        return 3
    fi
    kubectl config set-context "$ctx" --namespace "$ns" | sed 's/\.$/ using namespace "'"${ns}"'"./'
    ku
}

# list matching pod names
function knamegrep()
{
    local cmd t
    if [[ "$1" = '-s' ]]; then
        shift; cmd='s|^[^/]*/||'
    fi
    if [[ $# -lt 2 ]]; then
        echo 'usage: knamegrep [-s] { pods | nodes } <grep_args>....' >&2
        return 1
    fi
    t=$1; shift
    kubectl get $t -oname | grep "$@" | sed "${cmd}"
}

# list matching container names for a given pod
function kcongrep()
{
    local pod=$1; shift
    kubectl get "${pod}" -oyaml -o'jsonpath={.spec.containers[*].name}' | tr ' ' '\n' | grep "$@"
}

function keach()
{
    local opt cmd async=false prefix=false raw=false logger=: args=()

    while getopts 'aiprv' opt; do
        case $opt in
            a) async=true;;
            i) args+=(-ti);;
            p) prefix=true;;
            r) raw=true;;
            v) logger=echo;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                return 2
                ;;
        esac
    done

    shift $((OPTIND-1))

    if [[ $# -lt 2 ]]; then
        cat <<EOF >&2
usage: keach [OPTIONS] <pod_match> [@<container_name>] <command> [<arguments>...]

  Options:

    -a    run the command asynchronously for all matching pods
    -i    run the command interactive with a TTY allocated
    -p    prefix the command output with the name of the pod
    -r    do not escape the command and arguments (i.e. "raw")
    -v    show the kubectl command line used

EOF
        return 1
    fi

    pod_match=$1; shift

    conargs=()
    if [[ "${1::1}" = '@' ]]; then
        conargs+=(-c "${1:1}")
        shift
    fi

    if $raw; then
        cmd="$*"
    else
        cmd=$(printf ' %q' "$@" | sed 's/^ *//')
    fi

    pods=($(knamegrep -s pods ${pod_match}))
    for pod in "${pods[@]}"; do
        exargs=('exec' "${args[@]}" "${pod}" "${conargs[@]}" -- sh -c "TERM=xterm ${cmd}")
        $logger $(printf ' %q' kubectl "${exargs[@]}") >&2
        kubectl "${exargs[@]}"
    done
}

# helper to provide get unless action already provided in args
function _kget()
{
    local -n a=$1
    shift
    if [[ " ${a[@]} " =~ ' get ' ]] || \
           [[ " ${a[@]} " =~ ' describe ' ]] || \
           [[ " ${a[@]} " =~ ' delete ' ]]; then
        a+=("$@")
    else
        a+=(get "$@")
    fi
}

# simplify kubectl commands with abbreviations
function k()
{
    if [[ $# -lt 1 ]]; then
        cat <<EOF >&2
usage: k <kubectl_command_options>...

  Expansions:

    a     apply <filename>
    d     describe
    del   delete
    dep   deploy
    ex    exec
    exi   exec -ti
    l     logs

    g     get
    n     get nodes
    p     get pods
    s     get services
    ss    get statefulset
    ns    get namespaces
    sc    get secrets
    ev    get events
    cm    get configmaps

    tn    top node
    tp    top pod --containers

    all   --all-namespaces
    any   --all-namespaces
    w     -owide
    y     -oyaml

  Lookups:

    .<pod_match>        replace with matching pods
    ^<pod_match>        replace with FIRST matching pod
    @<container_match>  replace with FIRST matching container in pod (requires ^<pod_match>)
    ,<node_match>       replace with matching nodes

  Examples:

    k p                        # => kubectl get pods
    k g .odd y                 # => kubectl get pod/oddjob-2231453331-sj56r -oyaml
    k exi ^collab @nginx ash   # => kubectl exec -ti collab-3928615836-37fv4 -c nginx ash
    k l ^back @back --tail=5   # => kubectl logs backburner-1444197888-7xsgk -c backburner --tail=5

EOF
        return 1
    fi

    local a pod res args=()

    while [[ $# -gt 0 ]]; do
        a=$1; shift
        case "$a" in
            a)
                if ! [[ -f "$1" ]]; then
                    echo "\"apply\" requires a path to a YAML file (tried \"$1\")" >&2
                    return 2
                fi
                args+=(apply -f "$1"); shift
                ;;
            any|all) args+=(--all-namespaces);;
            cm) _kget args configmaps;;
            d) args+=(describe);;
            del) args+=(delete);;
            dep) _kget args deploy;;
            ev) _kget args events;;
            ex) args+=('exec');;
            exi) args+=('exec' -ti);;
            g) args+=(get);;
            l) args+=(logs);;
            n) _kget args nodes;;
            ns) _kget args namespaces;;
            p) _kget args pods;;
            pc)
                _kget args pods;
                args+=('-ocustom-columns=NAME:.metadata.name,CONTAINERS:.spec.containers[*].name,'`
                `'STATUS:.status.phase,RESTARTS:.status.containerStatuses[*].restartCount')
                ;;
            s) _kget args services;;
            sc) _kget args secrets;;
            ss) _kget args statefulset;;
            tn) args+=(top node);;
            tp) args+=(top pod --containers);;
            w) args+=(-owide);;
            y) args+=(-oyaml);;
            ,*) args+=($(knamegrep nodes "${a:1}"));;
            .*) args+=($(knamegrep pods "${a:1}"));;
            ^*)
                pod=$(knamegrep -s pods -m1 "${a:1}")
                args+=("${pod}")
                ;;
            @*)
                if [[ -z "${pod}" ]]; then
                    echo 'must select a pod with ^' >&2
                    return 3
                fi
                args+=(-c $(kcongrep "${pod}" -m1 "${a:1}"))
                ;;
            *)
                args+=("$a")
        esac
    done

    echo kubectl $(printf ' %q' "${args[@]}") >&2
    if [[ " ${args[@]} " =~ ' delete ' ]]; then
        read -r -p 'Are you sure? [y/N] ' res
        case "$res" in
            [yY][eE][sS]|[yY]) : ;;
            *) return 4
        esac
    fi

    kubectl "${args[@]}"
}

# report _ALL_ interesting k8s info (more than `get all` provides, but much slower)
function kall()
{
    local rsc res ns=$(kns)
    local ign='all|events|clusterroles|clusterrolebindings|customresourcedefinition|namespaces|'`
             `'nodes|persistentvolumeclaims|storageclasses'
    for rsc in $(kubectl get 2>&1 | awk '/^  \* /{if (!($2 ~ /^('"${ign}"')$/)) print $2}'); do
        if [[ "${rsc}" = 'persistentvolumes' ]]; then
            res=$(kubectl get "${rsc}" | awk 'NR==1{print};$6 ~ /^'"${ns}"'/{print}')
        else
            res=$(kubectl get "${rsc}" 2>&1)
        fi
        [[ $? -eq 0 ]] || continue
        [[ $(echo "$res" | wc -l ) -lt 2 ]] && continue
        cat <<EOF

----------------------------------------------------------------------
$(upcase "$rsc")

${res}
EOF
    done
}
