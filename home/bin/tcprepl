#!/usr/bin/env python

import argparse
import select
import socket
import ssl
import sys

parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('--line-ending', default="\r\n", help='Choose a different line ending')
parser.add_argument('--ssl', action='store_true', help='Enable TLS/SSL connection')
parser.add_argument('--insecure', action='store_true', help='Skip strict TLS/SSL checks')
parser.add_argument('host', help='Host or IP for connection')
parser.add_argument('port', nargs='?', type=int, default=80, help='TCP port for connection')
args = parser.parse_args()
print args

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
if args.ssl:
    ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    if not args.insecure:
        ssl_ctx.verify_mode = ssl.CERT_REQUIRED
        ssl_ctx.check_hostname = True
        ssl_ctx.load_default_certs()
    sock = ssl_ctx.wrap_socket(sock, server_hostname=args.host)

sock.connect((args.host, args.port))
print 'Connected: local=%s remote=%s' % (sock.getsockname(), sock.getpeername())

while True:
    if ssl_ctx:
        print ssl_ctx.session_stats()

    readables = [sys.stdin, sock]
    readable, writable, exceptional = select.select(readables, [], readables)

    for rfd in readable:
        if rfd is sys.stdin:
            line = sys.stdin.readline().rstrip()
            print '> ' + line
            sock.send(line + args.line_ending)
        else:
            for line in rfd.recv(128 * 1024).splitlines():
                print '< ' + line

    for efd in exceptional:
        print >>sys.stderr, 'FAILED:', efd
