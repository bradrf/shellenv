#!/usr/bin/env ruby

require 'filemagic'
require 'literate_randomizer'

if ARGV.size < 4
  $stderr.puts <<EOF

usage: #{File.basename $0, '.rb'} <percent_chance> <min> <max> <filename> [<filename>...]

EOF
  exit 1
end

MAX_FILE_SIZE = 64 * 1024

LANG_MARKS = {
  csharp: '//',
  python: '#',
  ruby: '#',
  shell: '#',
  js: '#',
}.each_value{|m| m << ' TextMuck: '} # mark lines added by the mucker (todo: make optional)

# todo: fix parsable types, somethign like the following
# (figure out how to insert, perhaps deep iterater and counters?)
# (figure out types to insert, (i.e. would be bad to insert string into number array))
LANG_PARSERS = {
  json: ->(fn){}
}

def get_line_for(lang)
  mark = LANG_MARKS[lang] or return ''
  # todo: match line endings of file!
  return mark + LiterateRandomizer.sentence + $/
end

chance = ARGV.shift.to_f / 100
range = (ARGV.shift.to_i..ARGV.shift.to_i)

magic = FileMagic.new
mime = FileMagic.mime

ARGV.each do |fn|
  if Random.rand > chance
    puts "Skipping #{fn} by chance"
    next
  end

  lang = case File.extname(fn)
         when '.cs' then :csharp
         when '.py' then :python
         when '.js' then :js
         when '.json' then :json
         when '.yaml','meta' then :yaml
         when '.html' then :html
         when ''
           case m = mime.file(fn)
           when /python/ then :python
           when /ruby/ then :ruby
           when /shell/ then :shell
           when /plain/
             case g = magic.file(fn)
             when /python/ then :python
             when /ruby/ then :ruby
             when /node/ then :js
             else
               puts "Skipping #{fn} by mime magic: #{m} (#{g})"
               next
             end
           else
             puts "Skipping #{fn} by mime type: #{m}"
             next
           end
         else
           puts "Skipping #{fn} by file extension"
           next
         end

  count = Random.rand(range)
  if count < 1
    puts "Skipping #{fn} with #{count} change"
    next
  end

  body = ''
  line_nums = []

  File.open(fn) do |file|
    # todo: support working with large files by reading next line
    if file.size > MAX_FILE_SIZE
      puts "Skipping #{fn} by size: #{file.size}"
      break
    end

    offsets = count.times.map{Random.rand(file.size)}.sort

    line_num = 0
    while !file.eof? && line = file.readline
      body << line
      line_num += 1
      offsets.size > 0 or next # read remainder of file
      if file.pos >= offsets.first # add a line as soon as passed the offset
        offsets.shift
        line_nums << (line_num+=1)
        body << get_line_for(lang)
      end
    end

    # concat any remaining lines
    while offsets.size > 0
      line_num += 1
      line_nums << line_num
      body << get_line_for(lang)
      offsets.shift
    end
  end

  body.size > 0 or next # probably too big

  # todo: use same charset as mime type indicates when writing!
  File.open(fn, 'wb') {|f| f.write(body)}

  puts "Modified #{fn} #{lang} line_nums #{line_nums.join(',')}"
end
