#!/usr/bin/env ruby

require 'thread'
require 'pathname'
require 'bytes'

# optional to make path names unique
begin require 'literate_randomizer'; rescue LoadError; end

if ARGV.size < 4
  bin, bm = Bytes::BINARY
  dec, dm = Bytes::DECIMAL
  $stderr.puts <<EOF

usage: #{File.basename $0, '.rb'} <minimum_size> <maximum_size> <count> <depth> [<percent_text>]

     The size MAY end with a unit label:
       * BINARY labels (#{bm} multiplier):  #{bin.join(', ')}
       * DECIMAL labels (#{dm} multiplier): #{dec.join(', ')}

     The count will determine the number of files to generate.

     The depth will determine the hierarchy of the files. The number of files will be randomly
     distributed among the tree.

     The percent text optional value indicates how many files should be text instead of binary.
     Default is none (i.e. all files have random binary content).

EOF
  exit 1
end

min,max,count,depth,percent_text = ARGV

min   = Bytes.dehumanize(min)
max   = Bytes.dehumanize(max)
count = count.to_i
depth = depth.to_i

if percent_text
  defined? LiterateRandomizer or raise 'Must gem install literate_randomizer for text content'
  percent_text = percent_text.to_f / 100
else
  percent_text = 0
end

if defined? LiterateRandomizer
  def gen_name
    LiterateRandomizer.word
  end
else
  def gen_name
    "gen#{Random.rand(0xffffffff)}"
  end
end

txt_worker_count = 4
txt_work_q = SizedQueue.new(txt_worker_count * 1000)
txt_workers = txt_worker_count.times.map do
  Thread.new do
    begin
      loop do
        len, fn = txt_work_q.pop
        fn.open('wb') do |file|
          while len > 0
            line = (LiterateRandomizer.sentence + $/)
            line.slice!(len..-1)
            len -= file.write(line)
          end
        end
      end
    rescue Exception => ex
      $stderr.puts "#{Thread.current} failed (txt): #{ex}", ex.backtrace
    end
  end
end

bin_worker_count = 4
bin_work_q = SizedQueue.new(bin_worker_count * 1000)
bin_workers = bin_worker_count.times.map do
  Thread.new do
    begin
      gen = Random.new
      loop do
        len, fn = bin_work_q.pop
        fn.open('wb') do |file|
          while len > 0
            len -= file.write(gen.bytes(len < 32768 ? len : 32768))
          end
        end
      end
    rescue Exception => ex
      $stderr.puts "#{Thread.current} failed (bin): #{ex}", ex.backtrace
    end
  end
end

paths = {}
gen = Random.new

count.times do |i|
  d = Random.rand(depth)
  if d < 1
    pn = Pathname.new('.')
  else
    pn = nil
    pns = paths[d] and pn = pns[gen.rand(pns.size)]
    unless pn
      pn = Pathname.new(gen_name)
      d.times{ pn += gen_name }
      pn.mkpath
      (paths[d] ||= []) << pn
    end
  end

  fn = pn + (gen_name + (gen.rand > percent_text ? '.bin' : '.txt'))
  len = gen.rand(min..max).round
  puts "#{Bytes.humanize(len, precision: 6.1)} => #{fn}"

  if fn.extname == '.txt'
    txt_work_q.push([len, fn])
  else
    bin_work_q.push([len, fn])
  end
end

until txt_work_q.empty? && bin_work_q.empty?
  $stdout.printf "\rWaiting for #{txt_work_q.size} txt and #{bin_work_q.size} bin jobs to complete..." + (' '*10)
  $stdout.flush
  sleep 0.5
end
$stdout.puts

(txt_workers + bin_workers).each do |th|
  th.kill
  th.join
end
