#!/usr/bin/env ruby

require 'shellwords'

bn = File.basename($0, '.rb')

if ARGV.size < 2
  $stderr.puts <<EOF

usage: #{bn} <iterations> <command> [<command_arguments>]

EOF
  exit 1
end

iterations = ARGV.shift.to_i
command    = ARGV.shelljoin

module SimpleStats
  def sum
    self.reduce(:+)
  end

  def mean
    self.length == 0 ? nil : self.sum / self.length
  end

  def median
    sorted = self.sort
    len = sorted.length
    return (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
  end

  def percentile(percentile)
    self.length > 1 or return self.first
    percentile /= 100.0
    sorted = self.sort
    len = sorted.length - 1
    k = (percentile * len + 1).floor - 1
    f = (percentile * len + 1).modulo(1)
    return sorted[k] + (f * (sorted[k+1] - sorted[k]))
  end

  def sample_variance
    m = self.mean
    sum = self.inject(0){|accum, i| accum + (i - m ) ** 2 }
    return sum / (self.length - 1).to_f
  end

  def standard_deviation
    Math.sqrt(self.sample_variance)
  end
end

class Array; include SimpleStats; end # supports Ruby 1.9.x

# finds the highest occuring unit of measure to report all stats consistently
# (i.e. it's difficult to read stats when a few might use a smaller unit)
def humanizer_for(array)
  counts = array.inject(Hash.new(0)) do |h, seconds|
    units = if    seconds < 0.001 then :us
            elsif seconds < 0.9   then :ms
            elsif seconds < 120   then :s
            elsif seconds < 3600  then :m
            else :h
            end
    h[units] += 1
    h
  end
  sorted = counts.sort_by{|k,v| v}
  units  = sorted.last[0]
  multiplier = case units
               when :us then 1000000
               when :ms then 1000
               when :s  then 1
               when :m  then 1.0 / 60
               else 1.0 / 3600
               end
  return ->(seconds) { '%.3f%s' % [seconds * multiplier, units] }
end

# Try to determine the cost of fork/exec/shell time and remove the fastest duration from the test
# results. Could consider using the mean but that may result in below-actual values in tests. Using
# the minimum helps shave off time to provide more realistic durations minmizing the concern of
# under-reporting.
overhead = 1
3.times do
  start = Time.now.to_f
  pid = Process.spawn('sh -c :')
  Process.wait2(pid)
  duration = Time.now.to_f - start
  duration < overhead and overhead = duration
end
$stderr.puts "<<< #{bn}: Overhead: #{overhead} seconds", ''

durations = []

(iterations.to_i + 1).times do |i|
  $stderr.puts ">>> #{bn}: %s: #{i}" % (i==0 ? 'Priming' : 'Iteration')
  status = nil
  start = Time.now.to_f
  pid = Process.spawn(command)
  pid, status = Process.wait2(pid)
  $stderr.puts "<<< #{bn}: Exit Status: #{status}"
  duration = Time.now.to_f - start - overhead
  i == 0 or durations.push(duration)
  $stderr.puts "<<< #{bn}: Duration: #{duration} seconds", ''
end

humanizer = humanizer_for(durations)

$stderr.puts "<<< #{bn}: Durations: #{durations.sort.map{|t| humanizer.call(t)}.join(', ')}", ''

$stderr.puts "<<< #{bn}: Results: "\
             "mean=#{humanizer.call(durations.mean)} "\
             "median=#{humanizer.call(durations.median)} "\
             "std=#{humanizer.call(durations.standard_deviation)} "\
             "90th=#{humanizer.call(durations.percentile(90))} "\
             "min=#{humanizer.call(durations.min)} "\
             "max=#{humanizer.call(durations.max)}"
