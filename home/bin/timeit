#!/usr/bin/env ruby

require 'shellwords'

bn = File.basename($0, '.rb')

if ARGV.size < 2
  $stderr.puts <<EOF

usage: #{bn} <iterations> <command> [<command_arguments>]

EOF
  exit 1
end

iterations = ARGV.shift.to_i
command = ARGV.shelljoin

module SimpleStats
  def sum
    self.reduce(:+)
  end

  def mean
    self.length == 0 ? nil : self.sum / self.length
  end

  def median
    sorted = self.sort
    len = sorted.length
    return (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0
  end

  def percentile(percentile)
    percentile /= 100.0
    sorted = self.sort
    len = sorted.length - 1
    k = (percentile * len + 1).floor - 1
    f = (percentile * len + 1).modulo(1)
    return sorted[k] + (f * (sorted[k+1] - sorted[k]))
  end

  def sample_variance
    m = self.mean
    sum = self.inject(0){|accum, i| accum + (i - m ) ** 2 }
    return sum / (self.length - 1).to_f
  end

  def standard_deviation
    return Math.sqrt(self.sample_variance)
  end
end

Array.include(SimpleStats)

# finds the highest occuring unit of measure to report all stats consistently
# (i.e. it's difficult to read stats when a few might use a smaller unit)
def humanizer_for(array)
  counts = array.inject(Hash.new(0)) do |h, seconds|
    units = if seconds < 0.001
             :us
           elsif seconds < 1
             :ms
           elsif seconds < 120
             :s
           elsif seconds < 3600
             :m
           else
             :h
           end
    h[units] += 1
    h
  end
  units = counts.sort_by{|k,v| v}.reverse.last[0]
  multiplier = case units
               when :us then 1000000
               when :ms then 1000
               when :s  then 1
               when :m  then 1.0 / 60
               else 1.0 / 3600
               end
  return ->(seconds) { '%.3f%s' % [seconds * multiplier, units] }
end

durations = []

(iterations.to_i + 1).times do |i|
  $stderr.puts ">>> #{bn}: %s: #{i}" % (i==0 ? 'Priming' : 'Iteration')
  status = nil
  start = Time.now.to_f
  pid = Process.spawn(command)
  pid, status = Process.wait2(pid)
  $stderr.puts "<<< #{bn}: Exit Status: #{status}"
  duration = Time.now.to_f - start
  i == 0 or durations.push(duration)
  $stderr.puts "<<< #{bn}: Duration: #{duration} seconds", ''
end

humanizer = humanizer_for(durations)

$stderr.puts "<<< #{bn}: Durations: #{durations.sort.map{|t| humanizer.call(t)}.join(', ')}", ''

$stderr.puts "<<< #{bn}: Results: "\
             "mean=#{humanizer.call(durations.mean)} "\
             "median=#{humanizer.call(durations.median)} "\
             "std=#{humanizer.call(durations.standard_deviation)} "\
             "90th=#{humanizer.call(durations.percentile(90))} "\
             "min=#{humanizer.call(durations.min)} "\
             "max=#{humanizer.call(durations.max)}"
