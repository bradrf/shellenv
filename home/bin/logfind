#!/usr/bin/env ruby -w

# ArgumentError Unmatched double quote: "a5574622ebf19f281cf294af197a365e6aefab4d7fe900099a9a141f3ad901a2 unitycloud-collab-store-production [24/Aug/2016:07:26:40 +0000] 54.254.250.41 arn:aws:sts::096016851792:assumed-role/collab/i-626e0b27 409508478588DA3F REST.GET.OBJECT 42262390-f1ce-47fe-a0d3-2732fe777b63/5d46cb843445665b2b6d976f48bc80ab \"GET /42262390-f1ce-47fe-a0d3-2732fe777b63/5d46cb843445665b2b6d976f48bc80ab?response-content-disposition=attachment%3B%20filename%3D%225d46cb843445665b2b6d976f48bc80ab%22&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAJMDME6GF7F3ZOVGA%2F20160824%2Fus-west-1%2Fs3%2Faws4_request&X-Amz-Date=20160824T072640Z&X-Amz-Expires=20&X-Amz-Security-Token=FQoDYXdzEIT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaDBf6NybpcFn2Y%2F1O4CKcA3TtPBcdEv%2FZ0HcxMcQI%2BqvQ3%2FFALiWw%2Fonfk6sWIAG9WD3GkMZ94HRMM9U0hS5LI7Bgl7qwFPEBfEo9hWBnGVp4T3HFkWjAfcT4a0dwlYbxkFUI8%2FBrxMxDxp33Z1rozAphWGm8v5hiRWpxLZlY9j1R5eseWUWi8gLS3ZsBElKziUeaw%2FS7xfQrZL5NBsaJDdJh%2FwJIzjopuDUM%2FZZ3rMklOFDx5gjBGSYjGbolHKJZovcqP7AozOJmDZtadwFuE%2FF6s9mn2zgtABsCNYO%2ByYc7PibnWolLDTDGeN6t3ox%2F5h8M57aEEsIkZ53tYao4H0SNplkGC3z0n0F7gYALJYkF%2BNU%2FknTLr7LBmoRvgunJvVaEs0nQb9HXDDC2HMhbuq%2F75A9i2zkNMWk38tujfBNk0yUj2R534NvBRMMKJZaqOIoAcuT1Q3CKegVjBwRcjQcgrpZeYvLrRZ7QCOpm9ccEhnsQtOR0WkYBhgJ4ZJsZonfaXXP3Mqd46qNF8y9LiBvimB8JeAKfeLBRdo%2BRMGwJ0%2Flx3Piz3zrFDmso3qT0vQU%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=6a21fe6bbdd0fdfde8ceed2ad733d9b4b2\n"

require 'set'
require 'shellwords'

if $stdout.tty?
  begin
    require 'ruby-progressbar'
  rescue LoadError
  end
end

opts = Set.new
ARGV.delete_if { |a| a.start_with?('--') and opts << a[2..-1] }
if !opts.include?('without-color') && (opts.include?('with-color') || $stdout.tty?)
  def colorize(str)
    %(\e[1;31;49m#{str}\e[0m)
  end
end

io = if ARGV.size == 3
       io_name = ARGV.pop
       File.open(io_name)
     else
       io_name = 'STDIN'
       $stdin
     end

if ARGV.size != 2
  BN = File.basename($PROGRAM_NAME, '.rb')
  $stderr.puts <<EOF

usage: #{BN} [--with[out]-color] { <regexp> | <colnum> } <block> [<filename>]

  Use either...
    - a Ruby regular expression or
    - a column number (starting at ONE, whitespace/quote-separated, negative value counts from end)
  ...to find interesting lines in a file, passing the matchdata to a handler block:
      * If the block returns an actual "true" boolean value, the line is reported.
      * If the block returns any other truthy value it is reported (as a string).
      * Otherwise, the next line is read.

  If a filename is not provided, lines are read from stdandard input (STDIN).

  Examples:
    > #{BN} 'duration=(\d+)' '|m| m[1].to_i > 1000' development.log
    > #{BN} -1 '|m| m.to_i > 10000' access.log

EOF
  exit 1
end

# the following builds up lambdas to avoid unecessary conditionals within the loop

match_arg = ARGV.shift
handler = binding.eval("lambda{#{ARGV.shift}}", '<block>')

matcher = if match_arg =~ /^-?\d+$/
            colnum = match_arg.to_i
            colnum > 0 and colnum -= 1
            if defined? colorize
              lambda do |line|
                cols = line.shellsplit
                match = cols[colnum]
                result = handler.call(match)
                if result == true
                  cols[colnum] = colorize(match)
                  line.replace(cols.map { |c| c.include?(' ') ? %("#{c}") : c }.join(' '))
                end
                result
              end
            else
              ->(line) { handler.call(line.shellsplit[colnum]) }
            end
          else
            regexp = Regexp.compile(match_arg)
            if defined? colorize
              lambda do |line|
                # this is much cheaper than using sub! and last_match, even w/ the re-match
                regexp.match(line) do |match|
                  result = handler.call(match)
                  result == true and line.sub!(regexp) { |m| colorize(m) }
                  result
                end
              end
            else
              ->(line) { regexp.match(line, &handler) }
            end
          end

if defined? ProgressBar
  if io == $stdin
    bar = ProgressBar.create(title: io_name,
                             format: '%t: LinesProcessed: %c, Elapsed%a', total: nil)
    progressor = ->(_) { bar.increment }
  else
    bar = ProgressBar.create(title: io_name,
                             format: '%t: PercentComplete: %J Elapsed%a', total: io.size)
    progressor = ->(bytes) { bar.progress += bytes }
  end
  logger = bar.method(:log)
else
  progressor = nil
  logger = $stdout.method(:puts)
end

running = true
Signal.trap('INT')  { running = false }
Signal.trap('TERM') { running = false }

begin
  while running && (line = io.gets)
    progressor and progressor.call(line.bytesize)
    begin
      result = matcher.call(line) or next
    rescue => ex
      $stderr.puts "#{ex.class} #{ex.message}", ex.backtrace[0]
      exit 2
    end
    logger.call(result == true ? line : result)
  end
rescue Errno::EPIPE
  # ignore when writing to pipe and the pipe is severed (e.g. logfind | head)
end

puts
